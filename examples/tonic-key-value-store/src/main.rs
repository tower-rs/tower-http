use bytes::Bytes;
use hyper::{
    header::{self, HeaderValue},
    Server,
};
use std::{
    collections::HashMap,
    net::SocketAddr,
    net::TcpListener,
    sync::{Arc, RwLock},
    time::Duration,
};
use structopt::StructOpt;
use tokio::io::AsyncReadExt;
use tonic::{async_trait, body::BoxBody, transport::Channel, Code, Request, Response, Status};
use tower::{make::Shared, ServiceBuilder};
use tower_http::{
    compression::CompressionLayer,
    decompression::{Decompression, DecompressionLayer},
    sensitive_header::SetSensitiveHeaderLayer,
    set_header::{SetRequestHeader, SetRequestHeaderLayer},
};

tonic::include_proto!("key_value_store");

/// Simple key/value store with an HTTP API
#[derive(Debug, StructOpt)]
struct Config {
    /// The port to listen on
    #[structopt(long, short = "p", default_value = "3000")]
    port: u16,

    #[structopt(subcommand)]
    command: Command,
}

#[derive(Debug, StructOpt)]
enum Command {
    /// Run the gRPC server
    Server,
    /// Get the value at some key
    Get {
        #[structopt(long, short = "k")]
        key: String,
    },
    /// Set a value at some key.
    ///
    /// The value will be read from stdin.
    Set {
        #[structopt(long, short = "k")]
        key: String,
    },
}

#[tokio::main]
async fn main() {
    // Setup tracing
    tracing_subscriber::fmt::init();

    // Parse command line arguments
    let config = Config::from_args();

    // The server address
    let addr = SocketAddr::from(([0, 0, 0, 0], config.port));

    match config.command {
        Command::Server => {
            // Create a `TcpListener`
            let listener = TcpListener::bind(addr).unwrap();

            // Run our service
            serve_forever(listener).await.expect("server error");
        }
        Command::Get { key } => {
            // Create a client for our server
            let mut client = make_client(addr).await.unwrap();

            // Issue a `GetRequest`
            let result = client.get(GetRequest { key }).await;

            match result {
                // If it succeeds print the value
                Ok(response) => {
                    let value_bytes = response.into_inner().value;
                    let value = String::from_utf8_lossy(&value_bytes[..]);
                    print!("{}", value);
                }
                // If not found we shouldn't panic
                Err(status) if status.code() == Code::NotFound => {
                    eprintln!("not found");
                    std::process::exit(1);
                }
                // Panic on other errors
                Err(status) => {
                    panic!("{:?}", status);
                }
            }
        }
        Command::Set { key } => {
            // Create a client for our server
            let mut client = make_client(addr).await.unwrap();

            // Read the value from stdin
            let mut stdin = tokio::io::stdin();
            let mut value = Vec::new();
            stdin.read_to_end(&mut value).await.unwrap();

            // Issue a `SetRequest`
            client.set(SetRequest { key, value }).await.unwrap();

            // All good :+1:
            println!("OK");
        }
    }
}

// We make this a separate function so we're able to call it from tests.
async fn serve_forever(listener: TcpListener) -> Result<(), hyper::Error> {
    // Build our database for holding the key/value pairs
    let db = Arc::new(RwLock::new(HashMap::new()));

    // Build our tonic `Service`
    let service = key_value_store_server::KeyValueStoreServer::new(ServerImpl { db });

    // Apply middlewares to our service
    let service = ServiceBuilder::new()
        // Set a timeout
        .timeout(Duration::from_secs(10))
        // Compress responses
        .layer(CompressionLayer::new())
        // Mark the `Authorization` header as sensitive so it doesn't show in logs
        .layer(SetSensitiveHeaderLayer::new(header::AUTHORIZATION))
        // Build our final `Service`
        .service(service);

    // Run the service using hyper
    let addr = listener.local_addr().unwrap();

    tracing::info!("Listening on {}", addr);

    // We cannot use `tonic::transport::Server` directly as it requires services to implement
    // `tonic::transport::NamedService` which tower-http middlewares don't
    Server::from_tcp(listener)
        .unwrap()
        .http2_only(true)
        .serve(Shared::new(service))
        .await?;

    Ok(())
}

// Implementation of the server trait generated by tonic
#[derive(Debug, Clone)]
struct ServerImpl {
    db: Arc<RwLock<HashMap<String, Bytes>>>,
}

#[async_trait]
impl key_value_store_server::KeyValueStore for ServerImpl {
    async fn get(&self, request: Request<GetRequest>) -> Result<Response<GetReply>, Status> {
        let key = request.into_inner().key;

        if let Some(value) = self.db.read().unwrap().get(&key).cloned() {
            let reply = GetReply {
                value: value.to_vec(),
            };

            Ok(Response::new(reply))
        } else {
            Err(Status::not_found("key not found"))
        }
    }

    async fn set(&self, request: Request<SetRequest>) -> Result<Response<SetReply>, Status> {
        let SetRequest { key, value } = request.into_inner();
        let value = Bytes::from(value);

        self.db.write().unwrap().insert(key, value);

        Ok(Response::new(SetReply {}))
    }
}

// Our final client type with middlewares applied
type Client = key_value_store_client::KeyValueStoreClient<
    Decompression<SetRequestHeader<Channel, HeaderValue>>,
>;

// Build a client with a few middlewares applied and connect to the server
async fn make_client(addr: SocketAddr) -> Result<Client, tonic::transport::Error> {
    let uri = format!("http://{}", addr)
        .parse::<tonic::transport::Uri>()
        .unwrap();

    // We have to use a `tonic::transport::Channel` as it implementes `Service` so we can apply
    // middlewares to it
    let channel = Channel::builder(uri).connect().await?;

    // Apply middlewares to our client
    let channel = ServiceBuilder::new()
        // Decompress response bodies
        .layer(DecompressionLayer::new())
        // Set a `User-Agent` header
        .layer(SetRequestHeaderLayer::<_, Request<BoxBody>>::overriding(
            header::USER_AGENT,
            HeaderValue::from_static("tonic-key-value-store"),
        ))
        // Build our final `Service`
        .service(channel);

    // Construct our tonic client
    Ok(key_value_store_client::KeyValueStoreClient::new(channel))
}
